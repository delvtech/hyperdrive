--- ../contracts/src/instances/ERC4626Hyperdrive.sol	2023-08-01 16:03:37.816111097 +0300
+++ 	2023-08-01 18:02:54.240307602 +0300
@@ -2,11 +2,11 @@
 pragma solidity 0.8.19;
 
 import { SafeERC20 } from "openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
-import { Hyperdrive } from "../Hyperdrive.sol";
-import { IERC20 } from "../interfaces/IERC20.sol";
-import { IERC4626 } from "../interfaces/IERC4626.sol";
-import { IHyperdrive } from "../interfaces/IHyperdrive.sol";
-import { FixedPointMath } from "../libraries/FixedPointMath.sol";
+import { Hyperdrive } from "./Hyperdrive.sol";
+import { IERC20 } from "../../contracts/src/interfaces/IERC20.sol";
+import { IERC4626 } from "../../contracts/src/interfaces/IERC4626.sol";
+import { IHyperdrive } from "../../contracts/src/interfaces/IHyperdrive.sol";
+import { FixedPointMath } from "../../contracts/src/libraries/FixedPointMath.sol";
 
 /// @author DELV
 /// @title ERC4626Hyperdrive
@@ -170,4 +170,8 @@
         uint256 balance = _target.balanceOf(address(this));
         _target.safeTransfer(_feeCollector, balance);
     }
+
+    function sharePrice() external view returns (uint256) {
+        return _pricePerShare();
+    }
 }
--- ../contracts/src/Hyperdrive.sol	2023-08-01 16:03:37.816111097 +0300
+++ 	2023-08-01 17:27:33.886089595 +0300
@@ -2,14 +2,17 @@
 pragma solidity 0.8.19;
 
 import { IERC20 } from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
-import { HyperdriveBase } from "./HyperdriveBase.sol";
+import { HyperdriveBase } from "../../contracts/src/HyperdriveBase.sol";
 import { HyperdriveLong } from "./HyperdriveLong.sol";
 import { HyperdriveShort } from "./HyperdriveShort.sol";
-import { IHyperdrive } from "./interfaces/IHyperdrive.sol";
-import { AssetId } from "./libraries/AssetId.sol";
-import { FixedPointMath } from "./libraries/FixedPointMath.sol";
-import { HyperdriveMath } from "./libraries/HyperdriveMath.sol";
-import { SafeCast } from "./libraries/SafeCast.sol";
+import { IHyperdrive } from "../../contracts/src/interfaces/IHyperdrive.sol";
+import { AssetId } from "../../contracts/src/libraries/AssetId.sol";
+import { FixedPointMath } from "../../contracts/src/libraries/FixedPointMath.sol";
+import { HyperdriveMath } from "../../contracts/src/libraries/HyperdriveMath.sol";
+import { SafeCast } from "../../contracts/src/libraries/SafeCast.sol";
+import { HyperdriveStorageGetters } from "../helpers/HyperdriveStorageGetters.sol";
+import { IHyperdriveTypes } from "../helpers/IHyperdriveTypes.sol";
+import { HyperdrivePresentValue } from "../helpers/HyperdrivePresentValue.sol";
 
 /// @author DELV
 /// @title Hyperdrive
@@ -20,7 +23,10 @@
 abstract contract Hyperdrive is
     HyperdriveBase,
     HyperdriveLong,
-    HyperdriveShort
+    HyperdriveShort,
+    HyperdriveStorageGetters,
+    IHyperdriveTypes,
+    HyperdrivePresentValue
 {
     using FixedPointMath for uint256;
     using SafeCast for uint256;
--- ../contracts/src/HyperdriveLP.sol	2023-08-01 16:03:37.816111097 +0300
+++ 	2023-08-02 11:22:36.535191233 +0300
@@ -1,13 +1,14 @@
 // SPDX-License-Identifier: Apache-2.0
 pragma solidity 0.8.19;
 
-import { HyperdriveBase } from "./HyperdriveBase.sol";
-import { HyperdriveTWAP } from "./HyperdriveTWAP.sol";
-import { IHyperdrive } from "./interfaces/IHyperdrive.sol";
-import { AssetId } from "./libraries/AssetId.sol";
-import { FixedPointMath } from "./libraries/FixedPointMath.sol";
-import { HyperdriveMath } from "./libraries/HyperdriveMath.sol";
-import { SafeCast } from "./libraries/SafeCast.sol";
+import { HyperdriveBase } from "../../contracts/src/HyperdriveBase.sol";
+import { HyperdriveTWAP } from "../../contracts/src/HyperdriveTWAP.sol";
+import { IHyperdrive } from "../../contracts/src/interfaces/IHyperdrive.sol";
+import { AssetId } from "../../contracts/src/libraries/AssetId.sol";
+import { FixedPointMath } from "../../contracts/src/libraries/FixedPointMath.sol";
+import { HyperdriveMath } from "../../contracts/src/libraries/HyperdriveMath.sol";
+import { SafeCast } from "../../contracts/src/libraries/SafeCast.sol";
+import { HyperdriveMathMock } from "../helpers/HyperdriveMathMock.sol";
 
 /// @author DELV
 /// @title HyperdriveLP
@@ -159,7 +160,7 @@
             // Calculate the present value before updating the reserves.
             HyperdriveMath.PresentValueParams
                 memory params = _getPresentValueParams(sharePrice);
-            uint256 startingPresentValue = HyperdriveMath.calculatePresentValue(
+            uint256 startingPresentValue = HyperdriveMathMock.calculatePresentValue(
                 params
             );
 
@@ -168,7 +169,7 @@
             _updateLiquidity(int256(shares));
             params.shareReserves = _marketState.shareReserves;
             params.bondReserves = _marketState.bondReserves;
-            endingPresentValue = HyperdriveMath.calculatePresentValue(params);
+            endingPresentValue = HyperdriveMathMock.calculatePresentValue(params);
 
             // The LP shares minted to the LP is derived by solving for the
             // change in LP shares that preserves the ratio of present value to
@@ -418,7 +419,7 @@
         // Calculate the starting present value of the pool.
         HyperdriveMath.PresentValueParams
             memory params = _getPresentValueParams(_sharePrice);
-        uint256 startingPresentValue = HyperdriveMath.calculatePresentValue(
+        uint256 startingPresentValue = HyperdriveMathMock.calculatePresentValue(
             params
         );
 
@@ -454,7 +455,7 @@
         _updateLiquidity(-int256(shareProceeds));
         params.shareReserves = _marketState.shareReserves;
         params.bondReserves = _marketState.bondReserves;
-        uint256 endingPresentValue = HyperdriveMath.calculatePresentValue(
+        uint256 endingPresentValue = HyperdriveMathMock.calculatePresentValue(
             params
         );
 
@@ -498,7 +499,7 @@
         uint256 _withdrawalSharesOutstanding,
         uint256 _sharePrice
     ) internal {
-        uint256 presentValue = HyperdriveMath.calculatePresentValue(
+        uint256 presentValue = HyperdriveMathMock.calculatePresentValue(
             _getPresentValueParams(_sharePrice)
         );
         uint256 lpTotalSupply = _totalSupply[AssetId._LP_ASSET_ID] +
--- ../contracts/src/HyperdriveShort.sol	2023-08-01 17:39:49.902763286 +0300
+++ 	2023-08-01 18:06:38.869474310 +0300
@@ -2,12 +2,13 @@
 pragma solidity 0.8.19;
 
 import { HyperdriveLP } from "./HyperdriveLP.sol";
-import { IHyperdrive } from "./interfaces/IHyperdrive.sol";
-import { AssetId } from "./libraries/AssetId.sol";
-import { FixedPointMath } from "./libraries/FixedPointMath.sol";
-import { HyperdriveMath } from "./libraries/HyperdriveMath.sol";
-import { SafeCast } from "./libraries/SafeCast.sol";
-import { YieldSpaceMath } from "./libraries/YieldSpaceMath.sol";
+import { IHyperdrive } from "../../contracts/src/interfaces/IHyperdrive.sol";
+import { AssetId } from "../../contracts/src/libraries/AssetId.sol";
+import { FixedPointMath } from "../../contracts/src/libraries/FixedPointMath.sol";
+import { HyperdriveMath } from "../../contracts/src/libraries/HyperdriveMath.sol";
+import { SafeCast } from "../../contracts/src/libraries/SafeCast.sol";
+import { YieldSpaceMath } from "../../contracts/src/libraries/YieldSpaceMath.sol";
+import { HyperdriveFeeMath } from "../helpers/HyperdriveFeeMath.sol";
 
 /// @author DELV
 /// @title HyperdriveShort
@@ -15,7 +16,7 @@
 /// @custom:disclaimer The language used in this code is for coding convenience
 ///                    only, and is not intended to, and does not, have any
 ///                    particular legal or regulatory significance.
-abstract contract HyperdriveShort is HyperdriveLP {
+abstract contract HyperdriveShort is HyperdriveLP, HyperdriveFeeMath {
     using FixedPointMath for uint256;
     using SafeCast for uint256;
 
@@ -437,7 +438,7 @@
 
         // Calculate the fees charged to the user (totalCurveFe) and the portion of those
         // fees that are paid to governance (governanceCurveFee).
-        uint256 totalCurveFee;
+        /*uint256 totalCurveFee;
         (
             totalCurveFee, // there is no flat fee on opening shorts
             ,
@@ -447,7 +448,15 @@
             _timeRemaining,
             spotPrice,
             _sharePrice
-        );
+        );*/
+        HDFee memory fee = MockCalculateFeesOutGivenBondsIn(_bondAmount, _timeRemaining, spotPrice, _sharePrice);
+        (
+            uint256 totalCurveFee,
+            ,
+            uint256 governanceCurveFee,
+            uint256 governanceFlatFee
+        ) = destructHDFee(fee);
+
 
         // ShareReservesDelta is the number of shares to remove from the shareReserves and
         // since the totalCurveFee includes the totalGovernanceFee it needs to be added back
@@ -516,7 +525,7 @@
         // Calculate the fees charged to the user (totalCurveFee and totalFlatFee)
         // and the portion of those fees that are paid to governance
         // (governanceCurveFee and governanceFlatFee).
-        (
+        /*(
             uint256 totalCurveFee,
             uint256 totalFlatFee,
             uint256 governanceCurveFee,
@@ -526,7 +535,14 @@
                 timeRemaining,
                 spotPrice,
                 _sharePrice
-            );
+            );*/
+        HDFee memory fee = MockCalculateFeesInGivenBondsOut(_bondAmount, timeRemaining, spotPrice, _sharePrice);
+        (
+            uint256 totalCurveFee,
+            uint256 totalFlatFee,
+            uint256 governanceCurveFee,
+            uint256 governanceFlatFee
+        ) = destructHDFee(fee);
 
         // Add the total curve fee minus the governance curve fee to the amount that will
         // be added to the share reserves. This ensures that the LPs are credited with the
--- ../contracts/src/HyperdriveLong.sol	2023-08-01 16:03:37.816111097 +0300
+++ 	2023-08-01 17:50:01.455306909 +0300
@@ -2,11 +2,12 @@
 pragma solidity 0.8.19;
 
 import { HyperdriveLP } from "./HyperdriveLP.sol";
-import { IHyperdrive } from "./interfaces/IHyperdrive.sol";
-import { AssetId } from "./libraries/AssetId.sol";
-import { FixedPointMath } from "./libraries/FixedPointMath.sol";
-import { HyperdriveMath } from "./libraries/HyperdriveMath.sol";
-import { SafeCast } from "./libraries/SafeCast.sol";
+import { IHyperdrive } from "../../contracts/src/interfaces/IHyperdrive.sol";
+import { AssetId } from "../../contracts/src/libraries/AssetId.sol";
+import { FixedPointMath } from "../../contracts/src/libraries/FixedPointMath.sol";
+import { HyperdriveMath } from "../../contracts/src/libraries/HyperdriveMath.sol";
+import { SafeCast } from "../../contracts/src/libraries/SafeCast.sol";
+import { HyperdriveFeeMath } from "../helpers/HyperdriveFeeMath.sol";
 
 /// @author DELV
 /// @title HyperdriveLong
@@ -14,7 +15,7 @@
 /// @custom:disclaimer The language used in this code is for coding convenience
 ///                    only, and is not intended to, and does not, have any
 ///                    particular legal or regulatory significance.
-abstract contract HyperdriveLong is HyperdriveLP {
+abstract contract HyperdriveLong is HyperdriveLP, HyperdriveFeeMath {
     using FixedPointMath for uint256;
     using SafeCast for uint256;
 
@@ -401,14 +402,22 @@
 
         // Calculate the fees charged to the user (totalCurveFee) and the portion of those
         // fees that are paid to governance (governanceCurveFee).
-        (
+        /*(
             uint256 totalCurveFee, // bonds
             uint256 governanceCurveFee // base
         ) = _calculateFeesOutGivenSharesIn(
                 _shareAmount,
                 spotPrice,
                 _sharePrice
-            );
+            );*/
+
+        HDFee memory fee = MockCalculateFeesOutGivenSharesIn(_shareAmount, bondProceeds, spotPrice, _sharePrice);
+        (
+             uint256 totalCurveFee,
+            ,
+             uint256 governanceCurveFee,
+ 
+        ) = destructHDFee(fee);
 
         // Calculate the number of bonds the trader receives.
         // This is the amount of bonds the trader receives minus the fees.
@@ -517,7 +526,7 @@
         // fees that are paid to governance (governanceCurveFee).
         uint256 totalCurveFee;
         uint256 totalFlatFee;
-        (
+        /*(
             totalCurveFee, // shares
             totalFlatFee, // shares
             totalGovernanceFee // shares
@@ -526,7 +535,10 @@
             timeRemaining,
             spotPrice,
             _sharePrice
-        );
+        );*/
+        HDFee memory fee = MockCalculateFeesOutGivenBondsIn(_bondAmount, timeRemaining, spotPrice, _sharePrice);
+        (totalCurveFee, totalFlatFee, ,) = destructHDFee(fee);
+        totalGovernanceFee = totalCurveFee.add(totalFlatFee).mulDown(_governanceFee);
 
         // Calculate the number of shares to remove from the shareReserves.
         // We do this bc the shareReservesDelta represents how many shares to remove
--- ../contracts/src/token/ForwarderFactory.sol	2023-08-02 10:51:29.405179151 +0300
+++ 	2023-08-02 10:53:05.885170887 +0300
@@ -23,10 +23,11 @@
     uint256 private _tokenId = 1;
 
     // For reference
-    bytes32 public constant ERC20LINK_HASH =
-        keccak256(type(ERC20Forwarder).creationCode);
+    bytes32 public immutable ERC20LINK_HASH;
 
-    constructor() {} // solhint-disable-line no-empty-blocks
+    constructor() {
+        ERC20LINK_HASH = keccak256(type(ERC20Forwarder).creationCode);
+    } // solhint-disable-line no-empty-blocks
 
     /// @notice Uses create2 to deploy a forwarder at a predictable address as part of
     ///         our ERC20 multitoken implementation.
@@ -42,18 +43,20 @@
         _tokenId = tokenId;
         _token = token;
         // The salt is the _tokenId hashed with the multi token
-        bytes32 salt = keccak256(abi.encode(token, tokenId));
+        // bytes32 salt = keccak256(abi.encode(token, tokenId));
         // Deploy using create2 with that salt
-        ERC20Forwarder deployed = new ERC20Forwarder{ salt: salt }();
+        // ERC20Forwarder deployed = new ERC20Forwarder{ salt: salt }();
         // As a consistency check we check that this is in the right address
-        require(address(deployed) == getForwarder(token, tokenId));
+        assert(address(tmp) == getForwarder(token, tokenId));
         // Reset the transient state
         _token = IMultiToken(address(1));
         _tokenId = 1;
         // return the deployed forwarder
-        return (deployed);
+        return (tmp);
     }
 
+    ERC20Forwarder tmp;
+
     /// @notice Returns the transient storage of this contract
     /// @return Returns the stored multitoken address and the sub token id
     function getDeployDetails() external view returns (IMultiToken, uint256) {
--- ../contracts/src/libraries/AssetId.sol	2023-08-01 16:03:37.816111097 +0300
+++ 	2023-08-02 10:56:34.415183493 +0300
@@ -1,8 +1,8 @@
 // SPDX-License-Identifier: Apache-2.0
 pragma solidity 0.8.19;
 
-import { FixedPointMath } from "./FixedPointMath.sol";
-import { IHyperdrive } from "../interfaces/IHyperdrive.sol";
+import { FixedPointMath } from "../../contracts/src/libraries/FixedPointMath.sol";
+import { IHyperdrive } from "../../contracts/src/interfaces/IHyperdrive.sol";
 
 /// @author DELV
 /// @title Hyperdrive
@@ -33,7 +33,7 @@
     function encodeAssetId(
         AssetIdPrefix _prefix,
         uint256 _timestamp
-    ) internal pure returns (uint256 id) {
+    ) external pure returns (uint256 id) {
         // [identifier: 8 bits][timestamp: 248 bits]
         if (
             _timestamp >
